## iOS에서 화면을 전환하는 방법

  - 소스 코드를 통해 전환하는 방법
  - 스토리보드가 제공하는 기능을 통해 전환하는 방법
  
## iOS에서 화면 전환이란
  
  - 뷰컨트롤러의 뷰 위에 다른 뷰를 가져와 바꿔치기
  - 뷰컨트롤러에서 다른 뷰컨트롤러를 호출하여 화면 전환
  - 네비게이션 컨트롤러를 사용하여 화면 전환
  - 화면 전환용 객체 세그웨이를 사용하여 화면 전환

화면 전환은 현재의 화면이 다른 화면으로 완전하게 교체되는 것이 아니라 현재 화면 위에 새로운 화면이 얹어지는 형태
> 기존 화면과 새로운 화면 사이에 서로 참조 관계가 성립함
> 직접 참조하거나, 화면 전환 객체를 통해 간접적으로 참조함


## 화면 전환 기법1: 뷰를 이용한 화면 전환(지양하는 방법)
> 하나의 뷰컨트롤러 안에 두 개의 루트뷰를 준비한 후, 상태에 따라 뷰를 적절히 교체함 
* 하나의 뷰컨트롤러가 두개 이상의 루트뷰를 관리해야 하기 때문에 좋지 않다.
* 다른 뷰컨트롤러의 루트뷰를 가져와 표시하는 방법 -> 네비게이션 컨트롤러를 이용하여 화면을 전환하면 루트 뷰와 뷰컨트롤러의 불일치 현상이 발생함

## 화면 전환 기법2: 뷰컨트롤러 직접 호출에 의한 화면 전환 / present 메서드의 호출 대상은 자기 
> 현재의 뷰컨트롤러에서 이동할 대상 뷰컨트롤러를 직접 호출해서 화면을 표시하는 방식 (Presentation 방식)
* present(_:animated:) -> UIViewController에 정의되어 있음
  present(<새로운 뷰컨트롤러 인스턴스>, animated:<애니메이션 여부>)
  
* present(_:animated:completion:) -> 화면 전환이 완료되는 시점에 맞추어 특정 로직을 실행해 주어야 할 떄
  completion -> 실행 구문을 클로저나 함수 형식으로 입력받아서, 화면 전환이 완전히 끝난 후에 호출해주는 역할
  *** 화면 전환은 비동기로 동작하기 때문에, 화면 전환이 완전히 끝난 후에 실행해야 할 구문이 있다면 클로저나 함수 형식으로 작성하여 completion 메서드에 넣은 다음 시스템이 호출해주기를 기다려야 함 ***

<프레젠테이션 방식으로 화면을 전환하는 경우>
기존 뷰컨트롤러 -> presentedViewController 속성에다 자신이 표시하고 있는 새로운 뷰컨트롤러의 포인터를 저장함
새로운 뷰컨트롤러 -> presentingViewController 속성에다 자신을 표시한 뷰 컨트롤러의 포인터를 저장함
  ** 서로 참조할 수 있다.
  
* dismiss(animated:) -> 이전 화면으로 복귀할 때 사용하는 메서드
* dismiss(animated:completion:) -> 완전히 복귀가 처리된 후에 실행할 구문을 받음
 > dismiss 되는 방식은 자신을 호출한 뷰컨에게 요청하는 형태. 즉 사라지게 하는 주체가 자신이 아닌 자신을 호출한 뷰컨트롤러이다.
 self.dismiss(animated:) (X)
 self.presentingViewController?.dismiss(animated:) (O) -> presentingViewController가 나를 호출한 뷰컨의 포인터를 가지고 있음
 
 ## 화면 전환 처리
  - 새로 표시할 뷰컨트롤러를 스토리 보드에서 읽어와 인스턴스화 하는 부분 필요
  > self.storyboard!.instantiateViewController(withIdentifier: "[Storyboard ID]") -> self.storyboard: 기본 스토리보드 파일을 가져옴
  ** modalTransitionStyle -> 어떤 스타일을 적용해서 전환할 것인지를 결정
  
  > coverVertical: 새로운 화면이 올라가면서 전환되는 효과 (기본 효과)
  > crossDissolve: 두 화면이 교차하면서 전 화면이 사라지고 다음 화면이 뚜렷하게 나타나는 효과
  > flipHorizontal: 화면 중앙 가상의 축을 기준으로 화면이 돌아가는 효과를 줌
  > particalCurl: 오르쪽 아래 모서리에서 시작해 페이지가 말려 올라가는 효과를 줌. 이때 전환될 뷰컨은 presentationStyle이 무조건 fullScreen


## 뷰컨트롤러와 클래스의 관계
  - 스토리 보드에 뷰컨트롤러를 추가하고 뷰컨트롤러 위에 Button, Label과 같은 객체를 올려두었다면 코드를 추가하거나 수정하기 위해서는 UIViewController를 상속받는
    Custom 클래스를 정의하여 스토리보드의 뷰컨트롤러와 연결시켜주어야 한다 (*필수)
    
  * 뷰컨트롤러는 자신을 위한 커스텀 클래스가 반드시 있어야 함!!

## Unwind
  - iOS 앱에서 이전 화면으로 돌아가는 것을 말함(dismiss)
  - 프레젠테이션 방식으로 화면을 전환하는 경우, 뷰컨트롤러의 포인터는 차례로 프레젠테이션 체인에 저장되고, Unwind 동작을 통해 체인에 저장된 뷰컨트롤러 포인터를 제거하는 방식으로 동작
  
  * 만약 이전 화면으로 돌아갈 때 dismiss 같은 Unwind 메서드를 사용하지 않고, 이전 화면을 다시 present 해버리면 뷰 컨트롤러의 포인터가 ARC에 의해 제거되지 않을 수도 있음..?!
  * UnWind 메서드는 메모리 해제와도 관련이 있기 때문에 화면 전환 방식에 따른 Unwind 메서드를 적절히 사용해야 함.

## 내비게이션 컨트롤러를 이용한 화면 전환 (UINavigationController)
  - NavigationViewController는 계층적 성격을 띠는 컨텐츠 구조를 관리하기 위한 컨트롤러
  - 화면 전환이 발생하는 뷰컨트롤러의 포인터를 Stack으로 관리함
  - 직접 컨텐츠를 담고 화면을 구성하진 않지만, 다른 뷰컨트롤러를 포함하고 있다.
  - 시작점 역할을 하는 rootViewController가 항상 존재한다.

  * pushViewController(_:animated:) -> 스택 최상위에 뷰컨트롤러를 추가할 때
  * popViewController(animated:) -> 스택의 최상위 뷰컨트롤러를 제거할 때
    - 이 메서드가 호출이 되면, 최상위 뷰컨트롤러 포인터를 제거하고 그 아래에 있는 뷰컨트롤러를 최상위 뷰컨트롤러로 설정함
    
  > 호출하는 대상은 navigationViewController. 만약 navigationViewController가 연결되어 있지 않다면 nil을 반환함
  > NavigationViewController 안에서 present를 통해 화면을 전환하는 경우에는 Navigation Bar가 생성되지 않는다. (원래는 자동 생성)

  
## Segueway
  - 스토리보드에서 화면의 전환과 연결관계를 관리하는 객체
  - 화면과 화면을 연결하기 위해 어떠한 코드도 필요하지 않음
  - 뷰컨트롤러 <-> 뷰컨트롤러 OR 버튼 <-> 뷰컨트롤러를 직접 연결하는 식으로 구성됨
  - 세그웨이는 한쪽으로만 (출발지, 목적지가 정해져 있음)
  - 세그웨이를 이용하면 뷰컨트롤러 인스턴스를 생성할 필요가 없기 때문에 뷰컨트롤러애 대한 정보가 필요 없다. (세그웨이가 연결 정보를 통해 자동으로 뷰컨트롤러 인스턴스를 생성해줌)
  - 스토리보드에 화면 전환 관계가 명료하게 표시되어 직관적으로 화면 사이의 관계를 파악할 수 있다.

  * 매뉴얼 세그웨이: 출발점이 뷰컨트롤러 자체인 경우 -> performSeque(withIdentifier:<세그웨이 식별자> sender:<세그웨이 실행 객체>) 메서드 사용하여 실행 (UIKit 프레임워크에 정의됨)
    - 다양한 조건에 따라 이동하는 페이지를 바꾸어 주어야 할 경우 사용
    > 화면 전환 효과를 주기 위해서는 [Transition] 속성을 사용

  * 액션 세그웨이 / 트리거 세그웨이: 출발점이 뷰컨트롤러 자체가 아니라 버튼이나 테이블 셀 등의 컨트롤인 경우 -> 버튼의 터치 이벤트등 이벤트 트리거에 의해 세그웨이 실행으로 바로 연결됨
    - Present Modally: present(_:animated:) 메서드를 이용한 화면 전환과 같은 기능

